// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract SchnorrBatchVerification {

    struct Token {
        address student;
        string ACLLink; // Link to ACL containing employer's hashed email
        uint256 expiration; // Expiration timestamp
        bool isValid;
    }

    mapping(address => string) public ACL; // Mapping to store student's hashed email (ACL)
    mapping(address => Token) public tokens; // Mapping to store tokens for each student

    // Function to store the ACL containing the employer's hashed email for a student
    function storeACL(
        address student, 
        string memory hashedEmail, 
        uint256 expiration
    ) public {
        // Store the hashed email for the student
        ACL[student] = hashedEmail;

        // Store additional token information if needed
        Token memory newToken = Token({
            student: student,
            ACLLink: "", // Set this if you need an ACL link
            expiration: expiration,
            isValid: true
        });

        tokens[student] = newToken;
    }

    // Function to generate a challenge based on commitment R
    function getChallenge(uint256 R) public view returns (uint256) {
        // Generate and return the challenge based on commitment R
        return uint256(keccak256(abi.encodePacked(R, block.timestamp))) % 23;  // Use 23 as the modulus (P)
    }

    // Schnorr Proof Verification Function
    function verifySchnorrProof(
        uint256 R, // Commitment (sent by employer)
        uint256 s, // Response (sent by employer)
        uint256 g, // Generator
        uint256 p, // Prime modulus
        uint256 c, // Challenge generated by blockchain
        address student,
        string memory employerHashedEmail
    ) public view returns (bool) {
        
        // Retrieve the hashed email from the ACL
        string memory storedHashedEmail = ACL[student];
        
        // Check if the employer's hashed email matches the one stored in ACL
        require(
            keccak256(abi.encodePacked(storedHashedEmail)) == keccak256(abi.encodePacked(employerHashedEmail)),
            "Employer's secret does not match"
        );

        // Continue Schnorr proof verification...
        // Verify Schnorr proof equation: g^s ?= R * (g^hashed_email)^c mod p
        uint256 lhs = modExp(g, s, p); // g^s mod p
        uint256 rhs = (R * modExp(g, uint256(keccak256(abi.encodePacked(employerHashedEmail))), p) ** c) % p; // R * g^hashed_email^c mod p

        return lhs == rhs;
    }

    // Modular exponentiation helper function (g^exp mod p)
    function modExp(uint256 base, uint256 exp, uint256 mod) internal pure returns (uint256) {
        uint256 result = 1;
        while (exp > 0) {
            if (exp % 2 == 1) {
                result = (result * base) % mod;
            }
            base = (base * base) % mod;
            exp /= 2;
        }
        return result;
    }

    // Function for batch verification of Schnorr proofs
    function batchVerifySchnorrProof(
        uint256[] memory R_batch, 
        uint256[] memory s_batch, 
        uint256[] memory g_batch, 
        uint256[] memory p_batch, 
        uint256[] memory c_batch, 
        address[] memory students_batch, 
        string[] memory employer_hashed_emails_batch
    ) public view returns (bool[] memory) {
        uint256 batchSize = R_batch.length;
        bool[] memory results = new bool[](batchSize);

        for (uint256 i = 0; i < batchSize; i++) {
            // Retrieve the student's hashed email from the ACL
            string memory storedHashedEmail = ACL[students_batch[i]];
            
            // Check if the employer's hashed email matches the one stored in ACL
            require(
                keccak256(abi.encodePacked(storedHashedEmail)) == keccak256(abi.encodePacked(employer_hashed_emails_batch[i])),
                "Employer's secret does not match"
            );

            // Perform Schnorr proof verification
            uint256 lhs = modExp(g_batch[i], s_batch[i], p_batch[i]); // g^s mod p
            uint256 rhs = (R_batch[i] * modExp(g_batch[i], uint256(keccak256(abi.encodePacked(employer_hashed_emails_batch[i]))), p_batch[i]) ** c_batch[i]) % p_batch[i]; // R * g^hashed_email^c mod p

            results[i] = (lhs == rhs); // Store the result for each verification
        }

        return results; // Return the batch results
    }
}
